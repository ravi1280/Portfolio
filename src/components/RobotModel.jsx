/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 3DMODEL.gltf 
Author: victory_mirosya (https://sketchfab.com/victory_mirosya)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/cute-robot-6aadb75f596742ada2814ad4593f0032
Title: cute robot
*/

import React from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import * as THREE from 'three'

export default function RobotModel(props) {
  const group = React.useRef()
  const { nodes, materials, animations } = useGLTF('/3DMODEL.gltf')
  const { actions } = useAnimations(animations, group)
  const blinkRef = React.useRef({ t: 0, phase: 'idle', blinksRemaining: 0 })
  const floatRef = React.useRef({ t: 0 })
  // Apply a green-themed palette to the model materials
  React.useEffect(() => {
    if (!materials) return
    // Base greens
  const primary = '#00F050' // bright green
  const deep = '#00A030' // deeper green
  const glow = '#00F050' // brighter glow
  const screen = '#ffffff' // white screen base

    // BODY: main chassis
    if (materials.BODY) {
      // Use brighter body color and slightly lower roughness for more light
      materials.BODY.color.set(primary)
      materials.BODY.roughness = 0.28
      materials.BODY.metalness = 0.65
  materials.BODY.side = THREE.DoubleSide
    }

    // Material.001: accents/panels
    if (materials['Material.001']) {
      materials['Material.001'].color.set(primary)
      materials['Material.001'].roughness = 0.4
      materials['Material.001'].metalness = 0.4
  materials['Material.001'].side = THREE.DoubleSide
    }

    // GLOW: emissive lines
    if (materials.GLOW) {
      materials.GLOW.color.set(glow)
      materials.GLOW.emissive?.set(glow)
      materials.GLOW.emissiveIntensity = 1.8
      materials.GLOW.roughness = 0.15
      materials.GLOW.metalness = 0.1
  materials.GLOW.side = THREE.DoubleSide
    }

    // SCREEN: face/screen tint
    if (materials.SCREEN) {
      materials.SCREEN.color.set(screen)
      materials.SCREEN.emissive?.set('#DEDEDE')
      materials.SCREEN.emissiveIntensity = 1.0
      materials.SCREEN.roughness = 0.4
      materials.SCREEN.metalness = 0.05
  materials.SCREEN.side = THREE.DoubleSide
    }

    // EYES: make eyes a bright emissive green
    if (materials.EYES) {
      materials.EYES.color.set('#00F050')
      materials.EYES.emissive?.set('#00F050')
      materials.EYES.emissiveIntensity = 1.6
  materials.EYES.side = THREE.DoubleSide
    }
  }, [materials])

  // Animate eye blink using morph targets if available
  useFrame((_, delta) => {
    // Gentle float
    floatRef.current.t += delta
    const t = floatRef.current.t
    if (group.current) {
      // Preserve base position from props and add gentle offsets
      const baseY = props.position?.[1] ?? group.current.position.y
      const baseX = props.position?.[0] ?? group.current.position.x
      group.current.position.y = baseY + Math.sin(t * 1.2) * 0.08
      group.current.position.x = baseX + Math.sin(t * 0.6) * 0.04
      // Oscillate yaw (left-right) around Y axis
      const yawAmplitude = 0.25 // radians ~14 degrees
      group.current.rotation.y = Math.sin(t * 0.8) * yawAmplitude
    }

    const left = nodes.mesh_2
    const right = nodes.mesh_3
    if (!left || !right || !left.morphTargetInfluences || !right.morphTargetInfluences) return

    const state = blinkRef.current
    state.t += delta
  // Blink every ~2 seconds; when triggered, do a double blink
  const blinkInterval = 2
    const closeSpeed = 8
    const openSpeed = 6
    const pauseBetweenBlinks = 0.12 // short pause between blinks

    // Trigger blink
    if (state.phase === 'idle' && state.t >= blinkInterval) {
      state.phase = 'closing'
      state.blinksRemaining = 2
      state.t = 0
    }

    // Compute influence (assuming target 0 is eyelid close)
    const iL = left.morphTargetInfluences[0] ?? 0
    const iR = right.morphTargetInfluences[0] ?? 0

    if (state.phase === 'closing') {
      const next = Math.min(1, iL + delta * closeSpeed)
      left.morphTargetInfluences[0] = next
      right.morphTargetInfluences[0] = next
      if (next >= 1) {
        state.phase = 'opening'
        state.t = 0
      }
    } else if (state.phase === 'opening') {
      const next = Math.max(0, iL - delta * openSpeed)
      left.morphTargetInfluences[0] = next
      right.morphTargetInfluences[0] = next
      if (next <= 0) {
        // One blink completed
        state.blinksRemaining = Math.max(0, (state.blinksRemaining ?? 0) - 1)
        if (state.blinksRemaining > 0) {
          state.phase = 'pause'
          state.t = 0
        } else {
          state.phase = 'idle'
          state.t = 0
        }
      }
    } else if (state.phase === 'pause') {
      // Short pause between two blinks
      if (state.t >= pauseBetweenBlinks) {
        state.phase = 'closing'
        state.t = 0
      }
    }
  })
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="root">
            <group name="GLTF_SceneRootNode" rotation={[Math.PI / 2, 0, 0]}>
              <group name="Cylinder_0" position={[0.005, 1.227, 0.854]} rotation={[Math.PI / 2, 0, 0]} scale={[0.153, 0.285, 0.153]}>
                <mesh name="Object_4" geometry={nodes.Object_4.geometry} material={materials.BODY} />
                <mesh name="Object_5" geometry={nodes.Object_5.geometry} material={materials.GLOW} />
                <mesh name="Object_6" geometry={nodes.Object_6.geometry} material={materials.SCREEN} />
              </group>
              <group name="Cube002_1" position={[0, 0, -0.279]} rotation={[0, 0.473, 0]} scale={[0.892, 0.611, 0.611]}>
                <mesh name="Object_8" geometry={nodes.Object_8.geometry} material={materials.BODY} />
                <mesh name="Object_9" geometry={nodes.Object_9.geometry} material={materials['Material.001']} />
              </group>
              <group name="Plane_2" position={[0.473, 1.235, 0.136]} rotation={[0, 0, -Math.PI / 2]} scale={[0.168, 0.21, 0.09]}>
                <mesh name="mesh_2" geometry={nodes.mesh_2.geometry} material={materials.EYES} morphTargetDictionary={nodes.mesh_2.morphTargetDictionary} morphTargetInfluences={nodes.mesh_2.morphTargetInfluences} />
              </group>
              <group name="Plane001_3" position={[0.473, 1.235, -0.138]} rotation={[0, 0, -Math.PI / 2]} scale={[0.168, 0.21, 0.09]}>
                <mesh name="mesh_3" geometry={nodes.mesh_3.geometry} material={materials.EYES} morphTargetDictionary={nodes.mesh_3.morphTargetDictionary} morphTargetInfluences={nodes.mesh_3.morphTargetInfluences} />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/3DMODEL.gltf')